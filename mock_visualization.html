<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Copy Generation Art Installation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            background: #0a0a0a;
            color: #e5e5e5;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-size: 13px;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 320px 1fr 280px;
            gap: 1px;
            height: 100vh;
            background: #1a1a1a;
        }
        
        /* Phase Indicator */
        .phase-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 8px 20px;
            border-radius: 20px;
            z-index: 1000;
            font-size: 12px;
            font-weight: 300;
            color: #4a5568;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: 1px solid rgba(255, 107, 157, 0.2);
        }
        
        .phase-active {
            background: linear-gradient(135deg, #ff6b9d, #c084fc);
            color: white;
            animation: phase-pulse 1s infinite;
        }
        
        @keyframes phase-pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        
        /* Left: Rhizomatiks-style visualizations - DARK */
        .left-panels {
            display: flex;
            flex-direction: column;
            gap: 1px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            transition: all 0.5s ease;
        }
        
        .left-panels.active {
            background: linear-gradient(135deg, #2a1a2a 0%, #3a2a3a 100%);
            box-shadow: 0 0 30px rgba(255, 107, 157, 0.3);
        }
        
        .left-panels.complete {
            background: linear-gradient(135deg, #1a2a1a 0%, #2a3a2a 100%);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }
        
        .art-module {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #000000;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .art-module.processing {
            background: #000000;
            border-left: 3px solid #ff6b9d;
            box-shadow: inset 0 0 30px rgba(255, 107, 157, 0.1);
        }
        
        .art-module.complete {
            background: #000000;
            border-left: 3px solid #10b981;
            box-shadow: inset 0 0 20px rgba(16, 185, 129, 0.05);
        }
        
        .art-header {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 100;
            font-size: 11px;
            font-weight: 300;
            color: #94a3b8;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .analysis-result {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            font-size: 14px;
            font-weight: 600;
            color: #ff6b9d;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }
        
        .analysis-result.show {
            opacity: 1;
            transform: scale(1);
        }
        
        .network-canvas {
            width: 100%;
            height: 100%;
        }
        
        .particle-field {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .data-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: particle-flow 6s linear infinite;
        }
        
        .particle-small {
            background: radial-gradient(circle, #ff6b9d, #8b5cf6);
            box-shadow: 0 0 10px rgba(255, 107, 157, 0.6);
        }
        
        .particle-medium {
            background: radial-gradient(circle, #8b5cf6, #06b6d4);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.6);
            width: 12px;
            height: 12px;
        }
        
        .particle-large {
            background: radial-gradient(circle, #06b6d4, #10b981);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.6);
            width: 16px;
            height: 16px;
        }
        
        @keyframes particle-flow {
            0% {
                transform: translateX(-30px) translateY(0px) scale(0);
                opacity: 0;
            }
            15% {
                opacity: 1;
                transform: scale(1);
            }
            85% {
                opacity: 1;
            }
            100% {
                transform: translateX(350px) translateY(-30px) scale(0);
                opacity: 0;
            }
        }
        
        .flow-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ff6b9d, #8b5cf6, #06b6d4, transparent);
            animation: flow-sweep 2s ease-in-out infinite;
            border-radius: 1px;
            box-shadow: 0 0 8px rgba(255, 107, 157, 0.4);
        }
        
        @keyframes flow-sweep {
            0%, 100% { 
                opacity: 0; 
                transform: scaleX(0.5);
            }
            50% { 
                opacity: 1; 
                transform: scaleX(1);
            }
        }
        
        .data-stream {
            position: absolute;
            width: 100%;
            height: 20px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 107, 157, 0.1) 25%, 
                rgba(139, 92, 246, 0.1) 50%, 
                rgba(6, 182, 212, 0.1) 75%, 
                transparent 100%);
            animation: stream-flow 4s ease-in-out infinite;
        }
        
        @keyframes stream-flow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        .data-node {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ff6b9d;
            border-radius: 50%;
            animation: node-pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes node-pulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 107, 157, 0.5);
            }
            50% { 
                transform: scale(1.8); 
                box-shadow: 0 0 20px rgba(255, 107, 157, 0.8);
            }
        }
        
        .data-wave {
            position: absolute;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 107, 157, 0.6), 
                rgba(139, 92, 246, 0.6), 
                transparent);
            animation: wave-travel 3s linear infinite;
            border-radius: 2px;
        }
        
        @keyframes wave-travel {
            0% { 
                transform: translateX(-100%); 
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { 
                transform: translateX(100%); 
                opacity: 0;
            }
        }
        
        .risk-grid {
            position: relative;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            gap: 1px;
            padding: 15px;
        }
        
        .risk-cell {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            transition: all 0.5s ease;
        }
        
        .risk-cell.active {
            background: linear-gradient(135deg, #ff6b9d, #8b5cf6);
            box-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
            animation: risk-pulse 2s ease-in-out infinite;
        }
        
        @keyframes risk-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        /* Center: BLACK BACKGROUND HANDWRITING */
        .center-workspace {
            background: #0a0a0a;
            padding: 16px;
            display: flex;
            flex-direction: column;
            transition: all 0.5s ease;
        }
        
        .center-workspace.active {
            background: #151515;
            box-shadow: 0 0 30px rgba(244, 164, 96, 0.2);
        }
        
        .handwriting-pad {
            flex: 1;
            background: #000000;
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 4px;
            padding: 25px;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.02),
                0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: row-reverse;
            align-items: stretch;
            transition: all 0.3s ease;
        }
        
        .handwritten-line {
            font-family: 'Noto Serif JP', 'Yu Mincho', '游明朝', 'YuMincho', '明朝', serif;
            font-size: 18px;
            color: #e2e8f0;
            margin-bottom: 0;
            line-height: 1.8;
            position: relative;
            height: 100%;
            writing-mode: vertical-rl;
            text-orientation: upright;
            padding: 15px;
            border-right: 1px solid rgba(148, 163, 184, 0.3);
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .typing-char {
            display: inline;
            animation: char-appear 0.1s ease-out;
        }
        
        @keyframes char-appear {
            from { 
                opacity: 0; 
                transform: scale(0.8);
            }
            to { 
                opacity: 1; 
                transform: scale(1);
            }
        }
        
        @keyframes char-appear {
            from { 
                opacity: 0; 
                transform: scale(0.8);
            }
            to { 
                opacity: 1; 
                transform: scale(1);
            }
        }
        
        .writing-cursor {
            display: inline-block;
            width: 22px;
            height: 2px;
            background: #e2e8f0;
            animation: cursor-blink 1s infinite;
            margin-top: 1px;
            writing-mode: vertical-rl;
        }
        
        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .workspace-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #374151;
            font-size: 10px;
            color: #9ca3af;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            color: #ffffff;
            font-weight: 600;
            font-family: 'Consolas', monospace;
            margin-top: 2px;
        }
        
        /* Right: Split evaluation panel - DARK */
        .right-evaluation {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 1px;
            transition: all 0.5s ease;
        }
        
        .right-evaluation.active {
            background: rgba(30, 20, 30, 0.95);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.3);
        }
        
        .feedback-section {
            flex: 1;
            padding: 15px;
            background: rgba(25, 25, 25, 0.95);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .analytics-section {
            flex: 1;
            padding: 15px;
            background: rgba(15, 15, 20, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(148, 163, 184, 0.4);
            transition: all 0.3s ease;
        }
        
        .eval-header {
            font-size: 11px;
            font-weight: 300;
            color: #94a3b8;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 107, 157, 0.3);
            display: flex;
            justify-content: space-between;
        }
        
        .analytics-header {
            font-size: 11px;
            font-weight: 300;
            color: #94a3b8;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.4);
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .metric-item {
            background: rgba(40, 40, 40, 0.7);
            border: 1px solid rgba(148, 163, 184, 0.4);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .metric-label {
            font-size: 8px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }
        
        .metric-value {
            font-size: 14px;
            font-weight: 500;
            color: #f1f5f9;
            font-family: 'Consolas', monospace;
        }
        
        .sentiment-bar {
            width: 100%;
            height: 4px;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }
        
        .sentiment-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981);
            border-radius: 2px;
            transition: width 0.5s ease;
        }
        
        .analytics-chart {
            height: 60px;
            background: rgba(255, 255, 255, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 4px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-bar {
            position: absolute;
            bottom: 0;
            width: 8px;
            background: linear-gradient(to top, #8b5cf6, #c084fc);
            border-radius: 1px 1px 0 0;
            animation: bar-grow 1s ease-out;
        }
        
        @keyframes bar-grow {
            from { height: 0; }
            to { height: var(--bar-height); }
        }
        
        .eval-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(255, 107, 157, 0.1);
            color: #ff6b9d;
            font-weight: 400;
        }
        
        .eval-status.active {
            background: linear-gradient(135deg, #ff6b9d, #c084fc);
            color: white;
        }
        
        .feedback-item {
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid rgba(255, 107, 157, 0.3);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 8px;
            font-size: 12px;
            animation: feedback-float 0.8s ease-out;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 20px rgba(255, 107, 157, 0.15);
            position: relative;
            transition: all 0.3s ease;
        }
        
        @keyframes feedback-float {
            from { 
                transform: translateX(50px) scale(0.95); 
                opacity: 0; 
            }
            to { 
                transform: translateX(0) scale(1); 
                opacity: 1; 
            }
        }
        
        .feedback-text {
            color: #cbd5e1;
            line-height: 1.4;
            font-weight: 400;
        }
        
        .control-button {
            background: #2563eb;
            color: #ffffff;
            border: none;
            padding: 10px 20px;
            font-size: 12px;
            font-weight: 600;
            font-family: 'Segoe UI', system-ui, sans-serif;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .control-button:hover {
            background: #1d4ed8;
        }
        
        .control-button.running {
            background: #10b981;
        }
        
        .cycle-counter {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 12px;
            color: #4a5568;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <button class="control-button" id="controlBtn" onclick="toggleAnalysis()" style="position: fixed; top: 20px; right: 20px; z-index: 1000;">
        Start Analysis
    </button>
    
    <div class="phase-indicator" id="phaseIndicator">
        System Ready
    </div>
    
    <div class="cycle-counter" id="cycleCounter">
        Cycle: 0 | Avg Score: 0
    </div>
    
    <div class="main-container">
        <!-- Left: Rhizomatiks-style Art Panels -->
        <div class="left-panels" id="leftPanels">
            <!-- Network Visualization -->
            <div class="art-module" id="networkModule">
                <div class="art-header">Sentiment Network</div>
                <div class="analysis-result" id="sentimentResult">0.847</div>
                <canvas class="network-canvas" id="networkCanvas"></canvas>
            </div>
            
            <!-- Data Flow Visualization -->
            <div class="art-module" id="flowModule">
                <div class="art-header">Data Flow Analysis</div>
                <div class="analysis-result" id="flowResult">156.3</div>
                <div class="particle-field" id="particleField">
                </div>
            </div>
            
            <!-- Risk Pattern Grid -->
            <div class="art-module" id="riskModule">
                <div class="art-header">Risk Pattern Detection</div>
                <div class="analysis-result" id="riskResult">LOW</div>
                <div class="risk-grid" id="riskGrid">
                </div>
            </div>
        </div>
        
        <!-- Center: PURE BLACK HANDWRITING -->
        <div class="center-workspace" id="centerWorkspace">
            <div class="handwriting-pad" id="handwritingPad">
            </div>
            <div class="workspace-stats">
                <div class="stat-item">
                    <span>Generated</span>
                    <span class="stat-value" id="generatedCount">0</span>
                </div>
                <div class="stat-item">
                    <span>Success Rate</span>
                    <span class="stat-value" id="successRate">0%</span>
                </div>
                <div class="stat-item">
                    <span>Avg. Score</span>
                    <span class="stat-value" id="avgScore">0.0</span>
                </div>
                <div class="stat-item">
                    <span>Time/Copy</span>
                    <span class="stat-value" id="timePerCopy">0ms</span>
                </div>
            </div>
        </div>
        
        <!-- Right: Split Evaluation Panel -->
        <div class="right-evaluation" id="rightEvaluation">
            <!-- Top: Natural Language Feedback -->
            <div class="feedback-section">
                <div class="eval-header">
                    User Feedback
                    <span class="eval-status" id="evalStatus">Standby</span>
                </div>
                <div id="feedbackStream" style="height: 100%; overflow-y: auto;">
                    <div style="color: #9ca3af; text-align: center; margin-top: 40px; font-size: 11px; font-weight: 300;">
                        Waiting for feedback...
                    </div>
                </div>
            </div>
            
            <!-- Bottom: Data Analytics -->
            <div class="analytics-section">
                <div class="analytics-header">
                    Copy Analytics
                </div>
                <div class="analytics-grid">
                    <div class="metric-item">
                        <div class="metric-label">Sentiment</div>
                        <div class="metric-value" id="sentimentScore">0.0</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Readability</div>
                        <div class="metric-value" id="readabilityScore">0%</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">Impact</div>
                        <div class="metric-value" id="impactScore">0.0</div>
                    </div>
                    <div class="metric-item">
                        <div class="metric-label">CTR Predict</div>
                        <div class="metric-value" id="ctrPredict">0.0%</div>
                    </div>
                </div>
                <div class="sentiment-bar">
                    <div class="sentiment-fill" id="sentimentBar" style="width: 0%"></div>
                </div>
                <div class="analytics-chart" id="analyticsChart">
                    <!-- Chart bars will be generated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // System state management
        let isRunning = false;
        let currentPhase = 'READY';
        let cycleCount = 0;
        let generatedCount = 0;
        let totalScore = 0;
        let avgScore = 0;
        let phaseTimeout;
        
        // Three.js variables
        let scene, camera, renderer, nodes = [], connections = [];
        let animationId;
        let particlePool = [];
        let lastConnectionUpdate = 0;
        
        // Phase management
        const PHASES = {
            READY: 'System Ready',
            ANALYSIS: 'Analyzing Data',
            GENERATION: 'Generating Copy',
            EVALUATION: 'Evaluating Quality',
            FEEDBACK: 'Processing Feedback',
            RESET: 'Preparing Next Cycle'
        };
        
        const copyLibrary = [
            "革新的な味わいが、新しい体験を約束します。",
            "限界を超える瞬間、それがブランドの真価です。", 
            "共有される喜びこそ、最高の価値創造。",
            "日常を特別に変える、魔法のような一口。",
            "記憶に残る味が、人生を豊かにします。",
            "今この瞬間から始まる、新しい物語。",
            "伝統と革新の融合が生み出す、唯一無二の体験。",
            "世界中で愛される理由は、心をつなぐ力にあります。",
            "感動的な瞬間を演出する、プレミアムな選択。",
            "130年の歴史が証明する、変わらない品質への誇り。"
        ];
        
        // Analysis results that improve over cycles
        let analysisData = {
            sentiment: 0.500,
            flow: 100,
            risk: 'MEDIUM'
        };
        
        // Persona feedback system
        const personas = {
            jk: {
                name: "女子高生",
                class: "persona-jk",
                positive: [
                    "これやば！めっちゃいい感じじゃん✨",
                    "えっ、これ好き！なんかエモい😍",
                    "やばくない？これ欲しくなる〜",
                    "めちゃ映えそう！インスタに載せたい📸",
                    "これ絶対バズるやつじゃん！",
                    "なにそれ、超可愛い💕",
                    "友達にも教えたい〜！"
                ],
                negative: [
                    "うーん、なんかピンとこない💦",
                    "ちょっと古くない？💧",
                    "なんか普通すぎかも...",
                    "もうちょっとキャッチーな方がいいかな",
                    "なんかダサくない？ごめん",
                    "これはちょっと...😅"
                ]
            },
            housewife: {
                name: "主婦",
                class: "persona-housewife", 
                positive: [
                    "これいいですね！実用的で助かります",
                    "家族みんなで使えそうで素敵です",
                    "お値段も手頃で魅力的ですね",
                    "安心して使えそうで良いです",
                    "これなら続けられそうです",
                    "家計にも優しくて嬉しいです",
                    "子供たちも喜びそうです"
                ],
                negative: [
                    "もう少し説明があると安心できます",
                    "ちょっと高いかなと思います",
                    "使い方が難しそうです",
                    "本当に効果があるか心配です",
                    "もう少し信頼できる情報が欲しいです",
                    "家族の反応が気になります"
                ]
            },
            elderly: {
                name: "シニア",
                class: "persona-elderly",
                positive: [
                    "なるほど、これは良いものですな",
                    "昔からあるものとは違いますが、良いですね",
                    "孫にも薦めたい商品です",
                    "品質が良さそうで安心します",
                    "長年の経験からも、これは良いと思います",
                    "老後の楽しみが増えそうです",
                    "健康にも良さそうで嬉しいです"
                ],
                negative: [
                    "ちょっと若い人向けかもしれませんね",
                    "使い方をもっと丁寧に教えてほしいです",
                    "昔の方が良かったような気もします",
                    "もう少し分かりやすい説明が欲しいです",
                    "年寄りには難しそうです",
                    "価格がちょっと心配ですね"
                ]
            }
        };
        
        function generatePersonaFeedback() {
            const personaKeys = Object.keys(personas);
            const selectedPersona = personas[personaKeys[Math.floor(Math.random() * personaKeys.length)]];
            
            // Score improves over cycles, affecting feedback sentiment
            const positiveChance = 0.4 + (cycleCount * 0.08) + (analysisData.sentiment * 0.3);
            const isPositive = Math.random() < Math.min(0.85, positiveChance);
            
            const feedbacks = isPositive ? selectedPersona.positive : selectedPersona.negative;
            const feedback = feedbacks[Math.floor(Math.random() * feedbacks.length)];
            
            return {
                persona: selectedPersona.name,
                class: selectedPersona.class,
                text: feedback,
                sentiment: isPositive ? 'positive' : 'negative'
            };
        }
        
        function toggleAnalysis() {
            const btn = document.getElementById('controlBtn');
            
            if (!isRunning) {
                startSystem();
                btn.textContent = 'System Running';
                btn.classList.add('running');
            } else {
                stopSystem();
                btn.textContent = 'Start Analysis';
                btn.classList.remove('running');
            }
        }
        
        function startSystem() {
            isRunning = true;
            cycleCount = 0;
            generatedCount = 0;
            totalScore = 0;
            avgScore = 0;
            
            updatePhase('ANALYSIS');
            startAnalysisPhase();
        }
        
        function stopSystem() {
            isRunning = false;
            currentPhase = 'READY';
            if (phaseTimeout) clearTimeout(phaseTimeout);
            if (animationId) cancelAnimationFrame(animationId);
            
            // Reset UI
            updatePhaseIndicator('System Ready');
            resetAllVisuals();
        }
        
        function updatePhase(phase) {
            if (!isRunning) return;
            
            currentPhase = phase;
            updatePhaseIndicator(PHASES[phase]);
            
            // Clear previous phase timeout
            if (phaseTimeout) clearTimeout(phaseTimeout);
        }
        
        function updatePhaseIndicator(text) {
            const indicator = document.getElementById('phaseIndicator');
            indicator.textContent = text;
            
            if (isRunning) {
                indicator.classList.add('phase-active');
            } else {
                indicator.classList.remove('phase-active');
            }
        }
        
        function updateCycleCounter() {
            document.getElementById('cycleCounter').textContent = 
                `Cycle: ${cycleCount} | Avg Score: ${avgScore}`;
        }
        
        // Phase 1: Analysis
        function startAnalysisPhase() {
            if (!isRunning) return;
            
            updatePhase('ANALYSIS');
            
            // Activate left panels
            document.getElementById('leftPanels').classList.add('active');
            document.getElementById('networkModule').classList.add('processing');
            document.getElementById('flowModule').classList.add('processing');
            document.getElementById('riskModule').classList.add('processing');
            
            // Start analysis animations
            initNetworkVisualization();
            startParticleFlow();
            startRiskGrid();
            
            // Complete analysis after 1 second (3x faster)
            phaseTimeout = setTimeout(() => {
                completeAnalysis();
            }, 1000);
        }
        
        function completeAnalysis() {
            if (!isRunning) return;
            
            // Improve analysis data over cycles
            analysisData.sentiment = Math.min(0.999, analysisData.sentiment + (Math.random() * 0.1 + 0.05));
            analysisData.flow = Math.min(200, analysisData.flow + (Math.random() * 20 + 10));
            analysisData.risk = cycleCount > 5 ? 'LOW' : cycleCount > 2 ? 'MEDIUM' : 'HIGH';
            
            // Show results
            document.getElementById('sentimentResult').textContent = analysisData.sentiment.toFixed(3);
            document.getElementById('flowResult').textContent = analysisData.flow.toFixed(1);
            document.getElementById('riskResult').textContent = analysisData.risk;
            
            // Mark as complete
            document.getElementById('leftPanels').classList.remove('active');
            document.getElementById('leftPanels').classList.add('complete');
            
            document.getElementById('networkModule').classList.remove('processing');
            document.getElementById('networkModule').classList.add('complete');
            document.getElementById('sentimentResult').classList.add('show');
            
            document.getElementById('flowModule').classList.remove('processing');
            document.getElementById('flowModule').classList.add('complete');
            document.getElementById('flowResult').classList.add('show');
            
            document.getElementById('riskModule').classList.remove('processing');
            document.getElementById('riskModule').classList.add('complete');
            document.getElementById('riskResult').classList.add('show');
            
            // Stop analysis animations
            stopAnalysisAnimations();
            
            // Move to generation phase
            phaseTimeout = setTimeout(() => {
                startGenerationPhase();
            }, 330);
        }
        
        // Phase 2: Generation
        function startGenerationPhase() {
            if (!isRunning) return;
            
            updatePhase('GENERATION');
            
            // Activate center workspace
            document.getElementById('centerWorkspace').classList.add('active');
            
            // Generate copy based on analysis
            generateOptimizedCopy();
            
            // Move to evaluation after copy is generated (700ms)
            phaseTimeout = setTimeout(() => {
                startEvaluationPhase();
            }, 700);
        }
        
        function generateOptimizedCopy() {
            const pad = document.getElementById('handwritingPad');
            
            // Select copy based on analysis results
            let copyIndex = Math.floor(Math.random() * copyLibrary.length);
            
            // Improve copy selection based on cycle
            if (cycleCount > 3) {
                copyIndex = Math.floor(Math.random() * 3); // Use better copies
            }
            
            const copy = copyLibrary[copyIndex];
            generatedCount++;
            
            const line = document.createElement('div');
            line.className = 'handwritten-line';
            
            // Add to the beginning (right side because of flex-direction: row-reverse)
            if (pad.firstChild) {
                pad.insertBefore(line, pad.firstChild);
            } else {
                pad.appendChild(line);
            }
            
            // Typewriter effect for vertical text
            let charIndex = 0;
            const cursor = document.createElement('span');
            cursor.className = 'writing-cursor';
            line.appendChild(cursor);
            
            const typeChar = () => {
                if (charIndex < copy.length && isRunning) {
                    const char = document.createElement('span');
                    char.className = 'typing-char';
                    char.textContent = copy[charIndex];
                    line.insertBefore(char, cursor);
                    charIndex++;
                    setTimeout(typeChar, 20); // Super fast typing (3x faster)
                } else {
                    if (line.contains(cursor)) {
                        line.removeChild(cursor);
                    }
                    // Auto scroll to show newest content (scroll to left)
                    pad.scrollLeft = 0;
                }
            };
            
            typeChar();
            
            // Update stats
            document.getElementById('generatedCount').textContent = generatedCount;
            document.getElementById('timePerCopy').textContent = '20ms'; // Reflect faster speed
            
            // Keep only 5 lines
            while (pad.children.length > 5) {
                pad.removeChild(pad.lastChild);
            }
        }
        
        // Phase 3: Evaluation
        function startEvaluationPhase() {
            if (!isRunning) return;
            
            updatePhase('EVALUATION');
            
            // Deactivate center
            document.getElementById('centerWorkspace').classList.remove('active');
            
            // Activate right panel
            document.getElementById('rightEvaluation').classList.add('active');
            document.getElementById('evalStatus').textContent = 'Evaluating';
            document.getElementById('evalStatus').classList.add('active');
            
            // Generate evaluation
            generateEvaluation();
            
            // Move to feedback after evaluation (500ms)
            phaseTimeout = setTimeout(() => {
                startFeedbackPhase();
            }, 500);
        }
        
        function generateEvaluation() {
            const feedbackStream = document.getElementById('feedbackStream');
            
            // Generate natural language feedback (top section)
            const feedbackCount = Math.floor(Math.random() * 2) + 2; // 2-3 feedbacks
            
            for (let i = 0; i < feedbackCount; i++) {
                setTimeout(() => {
                    if (!isRunning) return;
                    
                    const feedback = generatePersonaFeedback();
                    
                    const item = document.createElement('div');
                    item.className = 'feedback-item';
                    
                    item.innerHTML = `
                        <div class="feedback-text">${feedback.text}</div>
                    `;
                    
                    feedbackStream.insertBefore(item, feedbackStream.firstChild);
                    
                    // Calculate score based on feedback sentiment for stats
                    if (feedback.sentiment === 'positive') {
                        totalScore += Math.floor(Math.random() * 15 + 75);
                    } else {
                        totalScore += Math.floor(Math.random() * 20 + 55);
                    }
                    
                    avgScore = Math.round(totalScore / (generatedCount * 2)); // Adjust for multiple feedbacks
                    document.getElementById('avgScore').textContent = avgScore;
                    
                    // Remove old feedbacks
                    if (feedbackStream.children.length > 6) {
                        feedbackStream.removeChild(feedbackStream.lastChild);
                    }
                }, i * 100); // Much faster feedback staggering (3x faster)
            }
            
            // Generate analytics data (bottom section)
            generateAnalytics();
            
            // Update success rate based on cycle
            const successRate = Math.min(95, 60 + cycleCount * 4);
            document.getElementById('successRate').textContent = successRate + '%';
        }
        
        function generateAnalytics() {
            // Generate improving metrics based on cycle count
            const sentiment = Math.min(0.95, 0.3 + (cycleCount * 0.08) + (Math.random() * 0.2));
            const readability = Math.min(95, 45 + (cycleCount * 5) + Math.floor(Math.random() * 15));
            const impact = Math.min(9.5, 4.0 + (cycleCount * 0.3) + (Math.random() * 1.0));
            const ctr = Math.min(12.5, 2.5 + (cycleCount * 0.4) + (Math.random() * 1.5));
            
            // Update metrics
            document.getElementById('sentimentScore').textContent = sentiment.toFixed(1);
            document.getElementById('readabilityScore').textContent = readability + '%';
            document.getElementById('impactScore').textContent = impact.toFixed(1);
            document.getElementById('ctrPredict').textContent = ctr.toFixed(1) + '%';
            
            // Update sentiment bar
            const sentimentBar = document.getElementById('sentimentBar');
            sentimentBar.style.width = (sentiment * 100) + '%';
            
            // Update analytics chart
            updateAnalyticsChart([sentiment * 10, readability / 10, impact, ctr]);
        }
        
        function updateAnalyticsChart(values) {
            const chart = document.getElementById('analyticsChart');
            chart.innerHTML = '';
            
            values.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.left = (index * 15 + 10) + 'px';
                bar.style.setProperty('--bar-height', (value * 5) + 'px');
                bar.style.height = (value * 5) + 'px';
                
                chart.appendChild(bar);
            });
        }
        
        // Phase 4: Feedback
        function startFeedbackPhase() {
            if (!isRunning) return;
            
            updatePhase('FEEDBACK');
            
            // Process feedback (visual indication) - 170ms
            phaseTimeout = setTimeout(() => {
                startResetPhase();
            }, 170);
        }
        
        // Phase 5: Reset
        function startResetPhase() {
            if (!isRunning) return;
            
            updatePhase('RESET');
            
            // Reset visuals (except copy history)
            resetAnalysisVisuals();
            
            // Deactivate panels
            document.getElementById('rightEvaluation').classList.remove('active');
            document.getElementById('evalStatus').classList.remove('active');
            document.getElementById('evalStatus').textContent = 'Standby';
            
            cycleCount++;
            updateCycleCounter();
            
            // Start next cycle (330ms)
            phaseTimeout = setTimeout(() => {
                if (isRunning) {
                    startAnalysisPhase();
                }
            }, 330);
        }
        
        function resetAnalysisVisuals() {
            // Reset left panels
            document.getElementById('leftPanels').classList.remove('complete');
            
            ['networkModule', 'flowModule', 'riskModule'].forEach(id => {
                document.getElementById(id).classList.remove('complete');
            });
            
            ['sentimentResult', 'flowResult', 'riskResult'].forEach(id => {
                document.getElementById(id).classList.remove('show');
            });
            
            // Clear feedback stream (keep some history)
            const feedbackStream = document.getElementById('feedbackStream');
            while (feedbackStream.children.length > 3) {
                feedbackStream.removeChild(feedbackStream.lastChild);
            }
            
            // Reset analytics
            document.getElementById('sentimentScore').textContent = '0.0';
            document.getElementById('readabilityScore').textContent = '0%';
            document.getElementById('impactScore').textContent = '0.0';
            document.getElementById('ctrPredict').textContent = '0.0%';
            document.getElementById('sentimentBar').style.width = '0%';
            document.getElementById('analyticsChart').innerHTML = '';
        }
        
        function resetAllVisuals() {
            resetAnalysisVisuals();
            
            document.getElementById('leftPanels').classList.remove('active', 'complete');
            document.getElementById('centerWorkspace').classList.remove('active');
            document.getElementById('rightEvaluation').classList.remove('active');
            document.getElementById('evalStatus').classList.remove('active');
            document.getElementById('evalStatus').textContent = 'Standby';
            
            // Reset counters
            document.getElementById('cycleCounter').textContent = 'Cycle: 0 | Avg Score: 0';
            
            // Reset feedback stream to initial state
            document.getElementById('feedbackStream').innerHTML = `
                <div style="color: #9ca3af; text-align: center; margin-top: 40px; font-size: 11px; font-weight: 300;">
                    Waiting for feedback...
                </div>
            `;
        }
        
        function stopAnalysisAnimations() {
            // Stop particle creation and other animations
            const field = document.getElementById('particleField');
            field.innerHTML = '';
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        // Rhizomatiks-style Network Visualization
        function initNetworkVisualization() {
            const canvas = document.getElementById('networkCanvas');
            const rect = canvas.getBoundingClientRect();
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(rect.width, rect.height);
            renderer.setClearColor(0x000000, 0);
            
            camera.position.z = 3;
            
            // Create nodes
            const nodeGeometry = new THREE.SphereGeometry(0.015, 12, 12);
            for (let i = 0; i < 15; i++) {
                const hue = 0.9 + Math.random() * 0.1;
                const nodeMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(hue, 0.8, 0.6)
                });
                const nodeMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
                
                nodeMesh.position.set(
                    (Math.random() - 0.5) * 2.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 0.8
                );
                
                nodeMesh.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02, // 2x faster movement
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.01
                    )
                };
                
                scene.add(nodeMesh);
                nodes.push(nodeMesh);
            }
            
            animate3D();
        }
        
        function animate3D() {
            if (!isRunning || currentPhase !== 'ANALYSIS') return;
            
            const now = Date.now();
            
            nodes.forEach((node, index) => {
                node.position.add(node.userData.velocity);
                
                // Boundaries
                if (Math.abs(node.position.x) > 1.2) node.userData.velocity.x *= -1;
                if (Math.abs(node.position.y) > 0.8) node.userData.velocity.y *= -1;
                if (Math.abs(node.position.z) > 0.4) node.userData.velocity.z *= -1;
                
                // Organic movement (faster)
                node.position.x += Math.sin(now * 0.004 + index) * 0.002;
                node.position.y += Math.cos(now * 0.006 + index) * 0.002;
                
                const scale = 1 + Math.sin(now * 0.008 + index) * 0.5;
                node.scale.setScalar(scale);
            });
            
            // Update connections with optimized frequency
            if (now - lastConnectionUpdate > 50) { // More frequent for smoother visuals
                connections.forEach(conn => scene.remove(conn));
                connections = [];
                
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const distance = nodes[i].position.distanceTo(nodes[j].position);
                        if (distance < 0.8 && Math.random() > 0.7) { // Keep randomness for organic feel
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                nodes[i].position,
                                nodes[j].position
                            ]);
                            const material = new THREE.LineBasicMaterial({ 
                                color: 0xff6b9d,
                                opacity: 0.7 - distance * 0.3,
                                transparent: true
                            });
                            const line = new THREE.Line(geometry, material);
                            scene.add(line);
                            connections.push(line);
                        }
                    }
                }
                lastConnectionUpdate = now;
            }
            
            camera.position.x = Math.sin(now * 0.001) * 0.2;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
            animationId = requestAnimationFrame(animate3D);
        }
        
        function startParticleFlow() {
            if (currentPhase !== 'ANALYSIS') return;
            
            const field = document.getElementById('particleField');
            let activeParticles = 0;
            const maxParticles = 40; // Slightly increased for visual richness
            
            // Create multiple types of particles
            const createParticle = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS' || activeParticles > maxParticles) return;
                
                const particleTypes = ['particle-small', 'particle-medium', 'particle-large'];
                const randomType = particleTypes[Math.floor(Math.random() * particleTypes.length)];
                
                const particle = document.createElement('div');
                particle.className = `data-particle ${randomType}`;
                particle.style.top = Math.random() * (field.clientHeight - 20) + 'px';
                particle.style.animationDelay = Math.random() * 1 + 's';
                particle.style.animationDuration = (Math.random() * 1 + 2) + 's';
                
                field.appendChild(particle);
                activeParticles++;
                
                setTimeout(() => {
                    if (field.contains(particle)) {
                        field.removeChild(particle);
                        activeParticles--;
                    }
                }, 6000);
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(createParticle, 50); // Balanced frequency
                }
            };
            
            // Create flow lines
            const createFlowLine = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS') return;
                
                const line = document.createElement('div');
                line.className = 'flow-line';
                line.style.top = Math.random() * field.clientHeight + 'px';
                line.style.width = field.clientWidth + 'px';
                line.style.animationDelay = Math.random() * 2 + 's';
                line.style.animationDuration = (Math.random() * 0.5 + 1) + 's';
                
                field.appendChild(line);
                
                setTimeout(() => {
                    if (field.contains(line)) {
                        field.removeChild(line);
                    }
                }, 3000);
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(createFlowLine, 350);
                }
            };
            
            // Create data streams
            const createDataStream = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS') return;
                
                const stream = document.createElement('div');
                stream.className = 'data-stream';
                stream.style.top = Math.random() * field.clientHeight + 'px';
                stream.style.animationDelay = Math.random() * 1 + 's';
                
                field.appendChild(stream);
                
                setTimeout(() => {
                    if (field.contains(stream)) {
                        field.removeChild(stream);
                    }
                }, 4000);
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(createDataStream, 600);
                }
            };
            
            // Create pulsing nodes
            const createDataNode = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS') return;
                
                const node = document.createElement('div');
                node.className = 'data-node';
                node.style.left = Math.random() * field.clientWidth + 'px';
                node.style.top = Math.random() * field.clientHeight + 'px';
                node.style.animationDelay = Math.random() * 2 + 's';
                
                // Random colors
                const colors = ['#ff6b9d', '#8b5cf6', '#06b6d4', '#10b981'];
                node.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                field.appendChild(node);
                
                setTimeout(() => {
                    if (field.contains(node)) {
                        field.removeChild(node);
                    }
                }, 3000);
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(createDataNode, 300);
                }
            };
            
            // Create data waves
            const createDataWave = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS') return;
                
                const wave = document.createElement('div');
                wave.className = 'data-wave';
                wave.style.top = Math.random() * field.clientHeight + 'px';
                wave.style.animationDelay = Math.random() * 0.7 + 's';
                
                field.appendChild(wave);
                
                setTimeout(() => {
                    if (field.contains(wave)) {
                        field.removeChild(wave);
                    }
                }, 3000);
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(createDataWave, 500);
                }
            };
            
            // Start all particle types for rich visuals
            createParticle();
            createFlowLine();
            createDataStream();
            createDataNode();
            createDataWave();
        }
        
        function startRiskGrid() {
            if (currentPhase !== 'ANALYSIS') return;
            
            const grid = document.getElementById('riskGrid');
            grid.innerHTML = '';
            
            // Create grid cells
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < 180; i++) {
                const cell = document.createElement('div');
                cell.className = 'risk-cell';
                fragment.appendChild(cell);
            }
            grid.appendChild(fragment);
            
            const cells = Array.from(grid.querySelectorAll('.risk-cell'));
            
            const updateGrid = () => {
                if (!isRunning || currentPhase !== 'ANALYSIS') return;
                
                // Update multiple cells for better visual effect
                cells.forEach(cell => {
                    if (Math.random() > 0.92) {
                        cell.classList.add('active');
                        setTimeout(() => {
                            cell.classList.remove('active');
                        }, 2000);
                    }
                });
                
                if (currentPhase === 'ANALYSIS') {
                    setTimeout(updateGrid, 100); // Balanced update frequency
                }
            };
            
            updateGrid();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            if (renderer && camera) {
                const canvas = document.getElementById('networkCanvas');
                const rect = canvas.getBoundingClientRect();
                camera.aspect = rect.width / rect.height;
                camera.updateProjectionMatrix();
                renderer.setSize(rect.width, rect.height);
            }
        });
    </script>
</body>
</html>